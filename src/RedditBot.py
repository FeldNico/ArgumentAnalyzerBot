import re
import time

from dotenv import load_dotenv
import os
import praw

from DatabaseHelper import DatabaseHelper
from GenAI import GenAI


class RedditBot:
    def __init__(self):
        self.API = praw.Reddit(
            client_id=os.getenv("REDDIT_CLIENT_ID"),
            client_secret=os.getenv("REDDIT_CLIENT_SECRET"),
            username=os.getenv("REDDIT_USERNAME"),
            password=os.getenv("REDDIT_PASSWORD"),
            user_agent="ArgumentAnalyzer by u/ArgumentAnalyzerBot"  # Match your bot's actual username
        )
        self.GenAI = GenAI()
        self.DB = DatabaseHelper()

    def get_ancestor_comments_and_post(self,start_comment):
        """
        Traverses up the comment tree from a starting comment
        to the original post, collecting all ancestor comments.
        """
        path = []
        current_item = start_comment

        while True:
            parent = current_item.parent()
            if isinstance(parent, praw.models.Submission):
                # print(f"Reached original post (Submission): {parent.title} ({parent.url})")
                break

            elif isinstance(parent, praw.models.Comment):
                path.insert(0, parent)
                current_item = parent
                # print(f"Traversing up to parent comment: {current_item.body[:50]}...")
            else:
                print("Unexpected parent type or end of tree without reaching submission.")
                break

        return path, parent

    def constructThreadPrompt(self,original_post,ancestor_comments):
        comment_thread_for_analysis = ""
        if original_post:
            comment_thread_for_analysis += f"--- Original Post ---\n"
            comment_thread_for_analysis += f"Title: {original_post.title}\n"
            if original_post.selftext:
                comment_thread_for_analysis += f"Content: {original_post.selftext}\n"
            author_name = original_post.author.name if original_post.author else '[Deleted User]'
            comment_thread_for_analysis += f"By: u/{author_name}\n"
            comment_thread_for_analysis += "---\n\n"

        if ancestor_comments:
            comment_thread_for_analysis += "--- Comment Thread --- (Oldest to Newest, excluding trigger comment)\n"
            for comment_ancestor in ancestor_comments:
                author_name = comment_ancestor.author.name if comment_ancestor.author else '[Deleted User]'
                comment_thread_for_analysis += f"Comment ID: {comment_ancestor.id}\nUser ({author_name}): {comment_ancestor.body}\n---\n"
            comment_thread_for_analysis += "\n"

        return comment_thread_for_analysis

    def performFallacyAnalysis(self, comment):
        print(f"Bot triggered by comment: {comment.id} by {comment.author}")
        ancestor_comments, original_post = self.get_ancestor_comments_and_post(comment)
        comment_thread_for_analysis = self.constructThreadPrompt(original_post,ancestor_comments)

        analysis_output = None
        if not ancestor_comments and (not original_post.selftext and not original_post.title):
            reply_text = f"u/{comment.author}: It seems there are no parent comments or original post content for me to analyze in this thread. Please ensure the mention is in a comment that is part of a discussion you want analyzed."
            print(reply_text)
        else:
            analysis_output = self.GenAI.analyze_comment_thread_for_flaws(comment_thread_for_analysis)

            formatted_analysis = f"**Overall Discussion Analysis requested by u/{comment.author}:**\n {analysis_output['overall_summary']} ({analysis_output['overall_argument_type'].replace('_', ' ').capitalize()})\n\n"
            formatted_analysis += "**Individual Comment Breakdown:**\n"

            if analysis_output['analysis_entries']:
                for entry in analysis_output['analysis_entries']:
                    formatted_analysis += f"- **u/{entry['username']}** (Type: {entry['argument_type'].replace('_', ' ').capitalize()}):\n"
                    formatted_analysis += f"  > *{entry['comment_summary']}*  \n"  # Using blockquote for summary
                    if entry['argument_type'] == "fallacy" and entry['fallacy_type']:
                        formatted_analysis += f"  **Fallacy Type:** {entry['fallacy_type']}  \n"
                    if entry['flaw_description']:
                        formatted_analysis += f"  **Explanation:** {entry['flaw_description']}\n"
                    formatted_analysis += "\n"  # Add extra newline for readability between entries
            else:
                formatted_analysis += "  *No specific arguments identified in the comments.*\n\n"

            reply_text = f"**Argument Quality Analysis:**\n\n{formatted_analysis}For more information about fallacies visit: https://en.wikipedia.org/wiki/List_of_fallacies\n\n---\n\n*Beep boop. I am a bot. This analysis is generated by AI and may not be perfect. The analysis focused on the discussion thread leading up to this comment.*"

        try:
            reply = comment.reply(reply_text)
            if analysis_output:
                self.DB.storeAnalysis(original_post, comment.id, reply.id, analysis_output)
            print(f"Replied to comment {comment.id}")
        except praw.exceptions.RedditAPIException as e:
            print(f"Error replying to comment {comment.id}: {e}")
        except Exception as e:
            print(f"An unexpected error occurred while replying: {e}")



    def performClaimAnalysis(self, comment):
        print(f"Bot triggered by comment: {comment.id} by {comment.author}")
        ancestor_comments, original_post = self.get_ancestor_comments_and_post(comment)
        comment_thread_for_analysis = self.constructThreadPrompt(original_post, ancestor_comments)

        analysis_output = None
        if not ancestor_comments and (not original_post.selftext and not original_post.title):
            reply_text = f"u/{comment.author}: It seems there are no parent comments or original post content for me to analyze in this thread. Please ensure the mention is in a comment that is part of a discussion you want analyzed."
            print(reply_text)
        else:
            claim_json = self.GenAI.extract_claims_from_thread(comment_thread_for_analysis)
            reply_text = self.GenAI.factcheckClaims(claim_json)

        print(reply_text)

    def getStats(self, item, command_args):
        target_username = item.author.name  # Default to author of triggering comment
        if command_args:
            # Allow specifying a username, e.g., !userstats SomeUser
            target_username = command_args[0].replace('u/', '').strip()

        history_entries = self.DB.get_user_analysis_history(target_username)

        if not history_entries:
            reply_text = f"u/{item.author}: No analysis history found for u/{target_username}."
        else:
            valid_count = 0
            fallacy_count = 0
            no_argument_count = 0
            score = 0  # Score calculation: +1 for valid, -1 for fallacy

            valid_comments_links = []
            fallacy_comments_links = []
            no_argument_comments_links = []

            for entry in history_entries:
                comment_permalink = f"https://reddit.com/r/{entry['redditCommunity']}/comments/{entry['redditThreadID']}/comment/{entry['redditCommentID']}/"

                # Create a concise string for the link list
                link_item = f"([Link]({comment_permalink})) in r/{entry['redditCommunity']} (Overall: {entry['context_overall_argument_type'].replace('_', ' ').capitalize()})"

                if entry['argument_type'] == 'valid_argument':
                    valid_count += 1
                    score += 1
                    valid_comments_links.append(link_item)
                elif entry['argument_type'] == 'fallacy':
                    fallacy_count += 1
                    score -= 1
                    # Add fallacy type to link item for more context
                    fallacy_type_str = f" - {entry['fallacy_type']}" if entry['fallacy_type'] else ""
                    fallacy_comments_links.append(f"{link_item}{fallacy_type_str}")
                elif entry['argument_type'] == 'no_argument_found':
                    no_argument_count += 1
                    no_argument_comments_links.append(link_item)

            total_analyzed = valid_count + fallacy_count + no_argument_count

            # Get current timestamp
            from datetime import datetime  # Import datetime module
            current_time_str = datetime.now().strftime("%Y-%m-%d %H:%M:%S UTC")  # Format timestamp

            reply_text = f"**Argumentation Stats for u/{target_username} (requested by u/{item.author}):**\n\n"
            reply_text += f"*(Stats generated on: {current_time_str})*\n\n"  # Add timestamp

            reply_text += f"- **Total Comments Analyzed:** {total_analyzed}  \n"
            reply_text += f"- **Valid Arguments:** {valid_count}  \n"
            reply_text += f"- **Fallacies Detected:** {fallacy_count}  \n"
            reply_text += f"- **No Arguments Found:** {no_argument_count}  \n"
            reply_text += f"- **Overall Score:** {score}  \n"  # Present the score

            reply_text += "\n**Details by Type:**\n"

            if valid_comments_links:
                reply_text += "**Valid Arguments:**\n"
                for link in valid_comments_links:
                    reply_text += f"* {link}\n"
            else:
                reply_text += "No valid arguments detected yet.\n"
            reply_text += "\n"  # Blank line for spacing

            if fallacy_comments_links:
                reply_text += "**Fallacies Detected:**\n"
                for link in fallacy_comments_links:
                    reply_text += f"* {link}\n"
            else:
                reply_text += "No fallacies detected yet.\n"
            reply_text += "\n"  # Blank line for spacing

            if no_argument_comments_links:
                reply_text += "**No Arguments Found:**\n"
                for link in no_argument_comments_links:
                    reply_text += f"* {link}\n"
            else:
                reply_text += "No comments classified as 'no argument found' yet.\n"

            reply_text += "\n---\n\n*Score: +1 for each valid argument, -1 for each fallacy.*"
            reply_text += "\n*These stats reflect only comments analyzed by this bot.*"

        try:
            item.reply(reply_text)
            print(f"Replied to comment {item.id}")
        except praw.exceptions.RedditAPIException as e:
            print(f"Error replying to comment {item.id}: {e}")
        except Exception as e:
            print(f"An unexpected error occurred while replying: {e}")

    def handleComment(self, comment):
        bot_username_lower = self.API.user.me().name.lower()

        match = re.search(r'u/' + re.escape(bot_username_lower) + r'\s*(![a-zA-Z0-9_]+)(.*)', comment.body, re.IGNORECASE)

        if match and comment.was_comment:
            command = match.group(1).lower()
            command_args_str = match.group(2).strip()
            command_args = command_args_str.split() if command_args_str else []

            print(f"Bot mentioned in comment {comment.id} by {comment.author} with command: {command} args: {command_args}")

            if command == "!analyze":
                self.performFallacyAnalysis(comment)
            elif command == "!factcheck":
                self.performClaimAnalysis(comment)
            elif command == "!stats":
                self.getStats(comment,command_args)
            else:
                print(
                    f"Bot mentioned in {comment.id} but no specific analysis command found. Marking as read.")
        else:
            print(f"Item {comment.id} is not a relevant mention. Marking as read.")

    def handlePM(self,pm):
        pass

    def run(self):
        print(f"Starting bot, listening for mentions for: {self.API.user.me()}")

        for item in self.API.inbox.stream():
            if isinstance(item, praw.models.Comment):
                self.handleComment(item)
            elif isinstance(item, praw.models.Message):
                self.handlePM(item)

            #item.mark_read()
            time.sleep(1)